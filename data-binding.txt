Angular databinding
-------------------
Angular data binding just means connecting your TypeScript (component class) data with your HTML template (view) so that when data changes, UI updates automatically (and vice versa).

--------------------------------------------------------------------------------------------------

1. Interpolation (One-way binding â†’ TS â†’ HTML) - {{}}

ğŸ‘‰ Used when you just want to display data from your component in the template.

// app.component.ts
export class AppComponent {
  title = "Hello Angular!";
}

<!-- app.component.html -->
<h1>{{ title }}</h1>


âœ… Output: Hello Angular!
(If title changes in TS, it auto-updates in HTML.)

---------------------------------------------------------------

2. Property Binding (One-way binding â†’ TS â†’ HTML attribute) - []

ğŸ‘‰ Used to set properties/attributes of HTML elements or Angular components.

// app.component.ts
export class AppComponent {
  imageUrl = "https://angular.io/assets/images/logos/angular/angular.png";
}

<!-- app.component.html -->
<img [src]="imageUrl" alt="Angular logo" />


âœ… Here [src] takes value from imageUrl.
-----------------------------------------------------------------------

3. Event Binding (One-way binding â†’ HTML â†’ TS)

ğŸ‘‰ Used when user triggers an event (click, input, change, etc.) and you want to call a method in your component.

// app.component.ts
export class AppComponent {
  count = 0;

  increase() {
    this.count++;
  }
}

<!-- app.component.html -->
<button (click)="increase()">Click Me</button>
<p>Clicked {{ count }} times</p>


âœ… Clicking button calls increase() â†’ updates count â†’ UI auto-updates.
---------------------------------------------------------------------------------------------------

4. Two-way Binding (TS â†” HTML both ways)

ğŸ‘‰ Used when you want to sync data both ways (form inputs, user typing, etc.).
Requires FormsModule.

// app.component.ts
export class AppComponent {
  name = "Manoj";
}

<!-- app.component.html -->
<input [(ngModel)]="name" placeholder="Enter name" />
<p>Hello, {{ name }}!</p>


âœ… Typing in input updates name in TS, and TS updates the template instantly.
----------------------------------------------------------------------------------------------------

Using get() method

Getter methods are used when you want computed / read-only values.

<!-- app.component.html -->
<input [(ngModel)]="firstName" placeholder="First Name">
<input [(ngModel)]="lastName" placeholder="Last Name">
<p>Full Name: {{ fullName }}</p>
  
// app.component.ts
export class AppComponent {
firstName = "Manoj";
lastName = "Kumar";

// getter method
get fullName(): string {
  return this.firstName + " " + this.lastName;
}
}

âœ… Typing updates instantly.
Getter recalculates fullName automatically.
---------------------------------------------------------------------------------------------------
ğŸ”¹ Rule of Thumb

@Input() = only works on a child component â†’ because it means â€œIâ€™m expecting data from my parent.â€

@Output() = also only works on a child component â†’ because it means â€œIâ€™ll send events/data to my parent.â€
Parent components donâ€™t have @Input or @Output.
They only provide values (for childâ€™s @Input) or listen to events (for childâ€™s @Output).

ğŸ”¹ Example to Visualize
Child
// child.component.ts
import { Component, Input, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `
    <p>Child got: {{ message }}</p>
    <button (click)="notifyParent()">Notify Parent</button>
  `
})
export class ChildComponent {
  @Input() message!: string;  // parent -> child
  @Output() notify = new EventEmitter<string>();  // child -> parent

  notifyParent() {
    this.notify.emit("Child says Hello ğŸ‘‹");
  }
}

Parent
// parent.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-parent',
  template: `
    <h2>Parent Component</h2>
    <app-child [message]="parentMessage" 
               (notify)="onChildNotify($event)">
    </app-child>
    <p>Response from Child: {{ childResponse }}</p>
  `
})
export class ParentComponent {
  parentMessage = "Hello from Parent ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦";
  childResponse = "";

  onChildNotify(msg: string) {
    this.childResponse = msg;
  }
}

ğŸ”¹ Whatâ€™s Happening

Child has @Input and @Output.

Parent uses them like this:

[message]="parentMessage" â†’ supplies data to child.

(notify)="onChildNotify($event)" â†’ listens for events from child.

So Parent does not have @Input/@Output, but it interacts with them.

âœ… Conclusion

ğŸ‘‰ Only Child declares @Input and @Output.
ğŸ‘‰ Parent never declares them, but consumes/uses them.
--------------------------------------------------------------------------------------------------